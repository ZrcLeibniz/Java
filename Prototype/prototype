传统方式：
	1）简单易操作
	2）在创建新的对象时，总是需要获取原始对象的属性，如果创建的对象比较复杂，效率低下
	3）总是需要重新初始化对象，而不是动态的获得对象运行时的状态，不够灵活

改进思路：
	Java中的Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是
	需要实现clone的Java类必须实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力

原型模式：
	1）原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
	2）原型模式是一种创建型模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
	3）工作原理是，通过将一个原型对象传给要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝出它们自己来实施创建
	
在spring框架中bean的创建就使用了原型模式

浅拷贝：
	1）对于数据类型是基本数据类型h和字符串类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性复制一份给新的对象
	2）对于数据类型是引用数据类型的成员变量，例如数组，某个类的对象时，浅拷贝会进行引用传递，也就是将该成员变量的引用值
	（内存地址）赋值一份给新的对象。在这种情况下，在一个对象中修改成员变量会影响到另外一个对象的该成员变量值，因为实际上
	两个对象的成员变量指向同一个实例
	
深拷贝：
	1）复制对象的所有基本数据类型的成员变量值
	2）为所有引用数据类型的成员变量申请内存空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。
	3）深拷贝方式1：重写clone方法来实现深拷贝
	4）深拷贝方式2：通过对象序列化实现深拷贝
	
原型模式的注意事项：
	1）创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能提高效率。
	2）不用重新初始化对象，而是动态地获得对象运行时的状态
	3）如果原始对象发生变化（增加或者减少属性），其他克隆对象也会发生相应的变化，无需修改代码
	4）需要为每一个类配备一个克隆方法，这对于全新的类来说并不难，但对已有的类而言需要修改代码，违反了ocp原则
